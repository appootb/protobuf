
# inner_chat.proto API Document

*Document generated by protoc-gen-markdown. DO NOT EDIT!*

> APIs


* [InnerChat](#innerchat) - Inner chat service.


	* [Deliver (/message/inner/chat/deliver)](#deliver) - Deliver message.


	* [Kick (/message/inner/chat/conn/{product}/{unique_ids})](#kick) - Kick the connection.





<h2 id="innerchat">InnerChat</h2>

>  Inner chat service.



<h3 id="deliver">Deliver</h3>

>  Deliver message.



* HTTP Gateway

	* URL: `/message/inner/chat/deliver`
	* Method: `POST`
	* Content-Type: `application/json`

* Request Type: ***Package***

>  Router package.

|Field|proto type|JSON type|Comment|Default|Required|
|---|---|---|---|---|---|
|tag|[Tag](#tag) (oneof target)|object| Broadcast to specified tag(s)|-|false|
|conn|[Connections](#connections) (oneof target)|object| Forward to specified connections|-|false|
|sn|string|string| Package sn|-|true|
|posts|array [[Post](#post)]|array| Message posts|-|false|




> JSON Demo

```json
{
  "tag": {
    "product": "string",
    "name": "string",
    "prefixed": true
  },
  "conn": {
    "product": "string",
    "unique_ids": [
      "string"
    ]
  },
  "sn": "string",
  "posts": [
    {
      "postmark": {
        "category": "CATEGORY_UNSPECIFIED (0) | CATEGORY_PRIVATE (1) | CATEGORY_GROUP (2) | CATEGORY_CHANNEL (3) | CATEGORY_ROOM (4)",
        "sender": "string($int64)",
        "receiver": "string($int64)",
        "unique_id": "string($int64)",
        "expire": "1.000340012s",
        "timestamp": "1972-01-01T10:00:20.021Z"
      },
      "type": "TYPE_UNSPECIFIED (0) | TYPE_TEXT (1) | TYPE_AUDIO (2) | TYPE_STICKER (3) | TYPE_PHOTO (4) | TYPE_VIDEO (5) | TYPE_GIF (6) | TYPE_FILE (7) | TYPE_LOCATION (8) | TYPE_CONTACT (9) | TYPE_RECALL (10) | TYPE_READ (11)",
      "text": {
        "content": "string"
      },
      "resource": {
        "url": "string",
        "thumbnail": "string"
      },
      "coordinate": {
        "latitude": 3.1415926,
        "longitude": 3.1415926
      }
    }
  ]
}
```



* Response Type: ***Empty***

>  A generic empty message that you can re-use to avoid defining duplicated
>  empty messages in your APIs. A typical example is to use it as the request
>  or the response type of an API method. For instance:
> 
>      service Foo {
>        rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty);
>      }
> 
>  The JSON representation for `Empty` is empty JSON object `{}`.

|Field|proto type|JSON type|Comment|Default|Required|
|---|---|---|---|---|---|



> JSON Demo

```json
{}
```




<h3 id="kick">Kick</h3>

>  Kick the connection.



* HTTP Gateway

	* URL: `/message/inner/chat/conn/{product}/{unique_ids}`
	* Method: `DELETE`


* Request Type: ***Connections***

>  Connections.

|Field|proto type|JSON type|Comment|Default|Required|
|---|---|---|---|---|---|
|product|string|string| Product name|-|true|
|unique_ids|array [string]|string| Unique IDs|-|false|






* Response Type: ***Empty***

>  A generic empty message that you can re-use to avoid defining duplicated
>  empty messages in your APIs. A typical example is to use it as the request
>  or the response type of an API method. For instance:
> 
>      service Foo {
>        rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty);
>      }
> 
>  The JSON representation for `Empty` is empty JSON object `{}`.

|Field|proto type|JSON type|Comment|Default|Required|
|---|---|---|---|---|---|



> JSON Demo

```json
{}
```






********

## *Embed Messages*





<h3 id="category">Category</h3>

>  Message category enums.

* Enum

|Name (string)|Value (integer)|Comment|
|---|---|---|
|CATEGORY_UNSPECIFIED|0| Unspecified|
|CATEGORY_PRIVATE|1| Private chat|
|CATEGORY_GROUP|2| Group chat|
|CATEGORY_CHANNEL|3| Channel|
|CATEGORY_ROOM|4| Chatroom|


<h3 id="type">Type</h3>

>  Message type enums.

* Enum

|Name (string)|Value (integer)|Comment|
|---|---|---|
|TYPE_UNSPECIFIED|0| Unspecified|
|TYPE_TEXT|1| Text|
|TYPE_AUDIO|2| Audio|
|TYPE_STICKER|3| Sticker|
|TYPE_PHOTO|4| Photo|
|TYPE_VIDEO|5| Video|
|TYPE_GIF|6| Gif|
|TYPE_FILE|7| File|
|TYPE_LOCATION|8| Location|
|TYPE_CONTACT|9| Contact|
|TYPE_RECALL|10| Recall|
|TYPE_READ|11| Message read receipt|








<h3 id="connections">Connections</h3>

>  Connections.

* Fields

|Field|proto type|JSON type|Comment|Default|Required|
|---|---|---|---|---|---|
|product|string|string| Product name|-|true|
|unique_ids|array [string]|string| Unique IDs|-|false|


<h3 id="location">Location</h3>

>  Location coordinate.

* Fields

|Field|proto type|JSON type|Comment|Default|Required|
|---|---|---|---|---|---|
|latitude|float|number/string| Latitude|-|true|
|longitude|float|number/string| Longitude|-|true|


<h3 id="media">Media</h3>

>  Media message.

* Fields

|Field|proto type|JSON type|Comment|Default|Required|
|---|---|---|---|---|---|
|url|string|string| Original URL of photo/video|-|true|
|thumbnail|string|string| Thumbnail for photo/video|-|false|


<h3 id="post">Post</h3>

>  Message post.

* Fields

|Field|proto type|JSON type|Comment|Default|Required|
|---|---|---|---|---|---|
|postmark|[Postmark](#postmark)|object| Message postmark|-|true|
|type|enum [Type](#type)|string/integer| Message type|-|true|
|text|[Text](#text) (oneof envelope)|object| Text content|-|false|
|resource|[Media](#media) (oneof envelope)|object| Media resource|-|false|
|coordinate|[Location](#location) (oneof envelope)|object| Location coordinate|-|false|


<h3 id="postmark">Postmark</h3>

>  Message postmark.

* Fields

|Field|proto type|JSON type|Comment|Default|Required|
|---|---|---|---|---|---|
|category|enum [Category](#category)|string/integer| Message category|-|true|
|sender|int64|string| Sender ID|-|true|
|receiver|int64|string| Receiver/group/room/channel ID|-|true|
|unique_id|int64|string| Message ID, generated in server-side|-|false|
|expire|[Duration](#duration)|string ("1.000340012s")| Message expiration|-|false|
|timestamp|[Timestamp](#timestamp)|string ("1972-01-01T10:00:20.021Z")| Message timestamp|-|false|


<h3 id="tag">Tag</h3>

>  Connection tags.

* Fields

|Field|proto type|JSON type|Comment|Default|Required|
|---|---|---|---|---|---|
|product|string|string| Product name|-|true|
|name|string|string| Tag name|-|true|
|prefixed|bool|true, false| If tag name is prefixed|-|false|


<h3 id="text">Text</h3>

>  Text message.

* Fields

|Field|proto type|JSON type|Comment|Default|Required|
|---|---|---|---|---|---|
|content|string|string| Text content|-|true|


<h3 id="duration">Duration</h3>

>  A Duration represents a signed, fixed-length span of time represented
>  as a count of seconds and fractions of seconds at nanosecond
>  resolution. It is independent of any calendar and concepts like "day"
>  or "month". It is related to Timestamp in that the difference between
>  two Timestamp values is a Duration and it can be added or subtracted
>  from a Timestamp. Range is approximately +-10,000 years.
> 
>  # Examples
> 
>  Example 1: Compute Duration from two Timestamps in pseudo code.
> 
>      Timestamp start = ...;
>      Timestamp end = ...;
>      Duration duration = ...;
> 
>      duration.seconds = end.seconds - start.seconds;
>      duration.nanos = end.nanos - start.nanos;
> 
>      if (duration.seconds < 0 && duration.nanos > 0) {
>        duration.seconds += 1;
>        duration.nanos -= 1000000000;
>      } else if (duration.seconds > 0 && duration.nanos < 0) {
>        duration.seconds -= 1;
>        duration.nanos += 1000000000;
>      }
> 
>  Example 2: Compute Timestamp from Timestamp + Duration in pseudo code.
> 
>      Timestamp start = ...;
>      Duration duration = ...;
>      Timestamp end = ...;
> 
>      end.seconds = start.seconds + duration.seconds;
>      end.nanos = start.nanos + duration.nanos;
> 
>      if (end.nanos < 0) {
>        end.seconds -= 1;
>        end.nanos += 1000000000;
>      } else if (end.nanos >= 1000000000) {
>        end.seconds += 1;
>        end.nanos -= 1000000000;
>      }
> 
>  Example 3: Compute Duration from datetime.timedelta in Python.
> 
>      td = datetime.timedelta(days=3, minutes=10)
>      duration = Duration()
>      duration.FromTimedelta(td)
> 
>  # JSON Mapping
> 
>  In JSON format, the Duration type is encoded as a string rather than an
>  object, where the string ends in the suffix "s" (indicating seconds) and
>  is preceded by the number of seconds, with nanoseconds expressed as
>  fractional seconds. For example, 3 seconds with 0 nanoseconds should be
>  encoded in JSON format as "3s", while 3 seconds and 1 nanosecond should
>  be expressed in JSON format as "3.000000001s", and 3 seconds and 1
>  microsecond should be expressed in JSON format as "3.000001s".

* Fields

|Field|proto type|JSON type|Comment|Default|Required|
|---|---|---|---|---|---|
|seconds|int64|string| Signed seconds of the span of time. Must be from -315,576,000,000<br> to +315,576,000,000 inclusive. Note: these bounds are computed from:<br> 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years|-|false|
|nanos|int|number/string| Signed fractions of a second at nanosecond resolution of the span<br> of time. Durations less than one second are represented with a 0<br> `seconds` field and a positive or negative `nanos` field. For durations<br> of one second or more, a non-zero value for the `nanos` field must be<br> of the same sign as the `seconds` field. Must be from -999,999,999<br> to +999,999,999 inclusive.|-|false|


<h3 id="timestamp">Timestamp</h3>

>  A Timestamp represents a point in time independent of any time zone or local
>  calendar, encoded as a count of seconds and fractions of seconds at
>  nanosecond resolution. The count is relative to an epoch at UTC midnight on
>  January 1, 1970, in the proleptic Gregorian calendar which extends the
>  Gregorian calendar backwards to year one.
> 
>  All minutes are 60 seconds long. Leap seconds are "smeared" so that no leap
>  second table is needed for interpretation, using a [24-hour linear
>  smear](https://developers.google.com/time/smear).
> 
>  The range is from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z. By
>  restricting to that range, we ensure that we can convert to and from [RFC
>  3339](https://www.ietf.org/rfc/rfc3339.txt) date strings.
> 
>  # Examples
> 
>  Example 1: Compute Timestamp from POSIX `time()`.
> 
>      Timestamp timestamp;
>      timestamp.set_seconds(time(NULL));
>      timestamp.set_nanos(0);
> 
>  Example 2: Compute Timestamp from POSIX `gettimeofday()`.
> 
>      struct timeval tv;
>      gettimeofday(&tv, NULL);
> 
>      Timestamp timestamp;
>      timestamp.set_seconds(tv.tv_sec);
>      timestamp.set_nanos(tv.tv_usec * 1000);
> 
>  Example 3: Compute Timestamp from Win32 `GetSystemTimeAsFileTime()`.
> 
>      FILETIME ft;
>      GetSystemTimeAsFileTime(&ft);
>      UINT64 ticks = (((UINT64)ft.dwHighDateTime) << 32) | ft.dwLowDateTime;
> 
>      // A Windows tick is 100 nanoseconds. Windows epoch 1601-01-01T00:00:00Z
>      // is 11644473600 seconds before Unix epoch 1970-01-01T00:00:00Z.
>      Timestamp timestamp;
>      timestamp.set_seconds((INT64) ((ticks / 10000000) - 11644473600LL));
>      timestamp.set_nanos((INT32) ((ticks % 10000000) * 100));
> 
>  Example 4: Compute Timestamp from Java `System.currentTimeMillis()`.
> 
>      long millis = System.currentTimeMillis();
> 
>      Timestamp timestamp = Timestamp.newBuilder().setSeconds(millis / 1000)
>          .setNanos((int) ((millis % 1000) * 1000000)).build();
> 
> 
>  Example 5: Compute Timestamp from current time in Python.
> 
>      timestamp = Timestamp()
>      timestamp.GetCurrentTime()
> 
>  # JSON Mapping
> 
>  In JSON format, the Timestamp type is encoded as a string in the
>  [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format. That is, the
>  format is "{year}-{month}-{day}T{hour}:{min}:{sec}[.{frac_sec}]Z"
>  where {year} is always expressed using four digits while {month}, {day},
>  {hour}, {min}, and {sec} are zero-padded to two digits each. The fractional
>  seconds, which can go up to 9 digits (i.e. up to 1 nanosecond resolution),
>  are optional. The "Z" suffix indicates the timezone ("UTC"); the timezone
>  is required. A proto3 JSON serializer should always use UTC (as indicated by
>  "Z") when printing the Timestamp type and a proto3 JSON parser should be
>  able to accept both UTC and other timezones (as indicated by an offset).
> 
>  For example, "2017-01-15T01:30:15.01Z" encodes 15.01 seconds past
>  01:30 UTC on January 15, 2017.
> 
>  In JavaScript, one can convert a Date object to this format using the
>  standard
>  [toISOString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString)
>  method. In Python, a standard `datetime.datetime` object can be converted
>  to this format using
>  [`strftime`](https://docs.python.org/2/library/time.html#time.strftime) with
>  the time format spec '%Y-%m-%dT%H:%M:%S.%fZ'. Likewise, in Java, one can use
>  the Joda Time's [`ISODateTimeFormat.dateTime()`](
>  http://www.joda.org/joda-time/apidocs/org/joda/time/format/ISODateTimeFormat.html#dateTime%2D%2D
>  ) to obtain a formatter capable of generating timestamps in this format.

* Fields

|Field|proto type|JSON type|Comment|Default|Required|
|---|---|---|---|---|---|
|seconds|int64|string| Represents seconds of UTC time since Unix epoch<br> 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to<br> 9999-12-31T23:59:59Z inclusive.|-|false|
|nanos|int|number/string| Non-negative fractions of a second at nanosecond resolution. Negative<br> second values with fractions must still have non-negative nanos values<br> that count forward in time. Must be from 0 to 999,999,999<br> inclusive.|-|false|





