
# inner_secret.proto API Document

*Document generated by protoc-gen-markdown. DO NOT EDIT!*

> APIs


* [InnerSecret](#innersecret) - Account inner secret service.


	* [GetSecretInfo (/account/inner/secret/info)](#getsecretinfo) - Get token info.





<h2 id="innersecret">InnerSecret</h2>

>  Account inner secret service.



<h3 id="getsecretinfo">GetSecretInfo</h3>

>  Get token info.



* HTTP Gateway

	* URL: `/account/inner/secret/info`
	* Method: `GET`


* Request Type: ***Secret***

>  Account secret.

|Field|proto type|JSON type|Comment|Default|Required|
|---|---|---|---|---|---|
|token|string|string| Account token|-|true|






* Response Type: ***Info***

>  Token secret info.

|Field|proto type|JSON type|Comment|Default|Required|
|---|---|---|---|---|---|
|type|enum [Type](#type)|string/integer| Secret type|-|false|
|algorithm|enum [Algorithm](#algorithm)|string/integer| Secret algorithm|-|false|
|issuer|string|string| Secret issuer|-|false|
|account|int64|string| Account ID|-|false|
|key_id|int64|string| Key ID|-|false|
|roles|array [string]|string| Account roles|-|false|
|subject|enum [Subject](#subject)|string/integer| Token subject|-|false|
|issued_at|[Timestamp](#timestamp)|string ("1972-01-01T10:00:20.021Z")| Issued timestamp|-|false|
|expired_at|[Timestamp](#timestamp)|string ("1972-01-01T10:00:20.021Z")| Expired timestamp|-|false|



> JSON Demo

```json
{
  "type": "CLIENT (0) | SERVER (1)",
  "algorithm": "None (0) | HMAC (1) | RSA (2) | PSS (3) | ECDSA (4) | EdDSA (5)",
  "issuer": "string",
  "account": "string($int64)",
  "key_id": "string($int64)",
  "roles": [
    "string"
  ],
  "subject": "NONE (0) | GUEST (1) | WEB (8) | PC (64) | MOBILE (512) | LOGGED_IN (584) | CLIENT (585) | SERVER (4096) | ANY (65535)",
  "issued_at": "1972-01-01T10:00:20.021Z",
  "expired_at": "1972-01-01T10:00:20.021Z"
}
```






********

## *Embed Messages*





<h3 id="subject">Subject</h3>

>  Method token subject.

* Enum

|Name (string)|Value (integer)|Comment|
|---|---|---|
|NONE|0| Public access, no token required [Default]|
|GUEST|1| Guest token, generated by client locally|
|WEB|8| Web token, signed for h5, web|
|PC|64| PC token, signed for MacOS, Windows or Linux app|
|MOBILE|512| Mobile token, signed for native mobile app|
|LOGGED_IN|584| Logged-in token, WEB | PC | MOBILE|
|CLIENT|585| Client token, GUEST | WEB | PC | MOBILE|
|SERVER|4096| Server token, signed for server usage|
|ANY|65535| Any token|


<h3 id="algorithm">Algorithm</h3>

>  Token algorithm

* Enum

|Name (string)|Value (integer)|Comment|
|---|---|---|
|None|0| None|
|HMAC|1| HMAC|
|RSA|2| RSA-PKCS|
|PSS|3| RSA-PSS|
|ECDSA|4| ECDSA|
|EdDSA|5| EdDSA|


<h3 id="type">Type</h3>

>  Secret type.

* Enum

|Name (string)|Value (integer)|Comment|
|---|---|---|
|CLIENT|0| For client usage|
|SERVER|1| For server usage|








<h3 id="timestamp">Timestamp</h3>

>  A Timestamp represents a point in time independent of any time zone or local
>  calendar, encoded as a count of seconds and fractions of seconds at
>  nanosecond resolution. The count is relative to an epoch at UTC midnight on
>  January 1, 1970, in the proleptic Gregorian calendar which extends the
>  Gregorian calendar backwards to year one.
> 
>  All minutes are 60 seconds long. Leap seconds are "smeared" so that no leap
>  second table is needed for interpretation, using a [24-hour linear
>  smear](https://developers.google.com/time/smear).
> 
>  The range is from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z. By
>  restricting to that range, we ensure that we can convert to and from [RFC
>  3339](https://www.ietf.org/rfc/rfc3339.txt) date strings.
> 
>  # Examples
> 
>  Example 1: Compute Timestamp from POSIX `time()`.
> 
>      Timestamp timestamp;
>      timestamp.set_seconds(time(NULL));
>      timestamp.set_nanos(0);
> 
>  Example 2: Compute Timestamp from POSIX `gettimeofday()`.
> 
>      struct timeval tv;
>      gettimeofday(&tv, NULL);
> 
>      Timestamp timestamp;
>      timestamp.set_seconds(tv.tv_sec);
>      timestamp.set_nanos(tv.tv_usec * 1000);
> 
>  Example 3: Compute Timestamp from Win32 `GetSystemTimeAsFileTime()`.
> 
>      FILETIME ft;
>      GetSystemTimeAsFileTime(&ft);
>      UINT64 ticks = (((UINT64)ft.dwHighDateTime) << 32) | ft.dwLowDateTime;
> 
>      // A Windows tick is 100 nanoseconds. Windows epoch 1601-01-01T00:00:00Z
>      // is 11644473600 seconds before Unix epoch 1970-01-01T00:00:00Z.
>      Timestamp timestamp;
>      timestamp.set_seconds((INT64) ((ticks / 10000000) - 11644473600LL));
>      timestamp.set_nanos((INT32) ((ticks % 10000000) * 100));
> 
>  Example 4: Compute Timestamp from Java `System.currentTimeMillis()`.
> 
>      long millis = System.currentTimeMillis();
> 
>      Timestamp timestamp = Timestamp.newBuilder().setSeconds(millis / 1000)
>          .setNanos((int) ((millis % 1000) * 1000000)).build();
> 
> 
>  Example 5: Compute Timestamp from current time in Python.
> 
>      timestamp = Timestamp()
>      timestamp.GetCurrentTime()
> 
>  # JSON Mapping
> 
>  In JSON format, the Timestamp type is encoded as a string in the
>  [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format. That is, the
>  format is "{year}-{month}-{day}T{hour}:{min}:{sec}[.{frac_sec}]Z"
>  where {year} is always expressed using four digits while {month}, {day},
>  {hour}, {min}, and {sec} are zero-padded to two digits each. The fractional
>  seconds, which can go up to 9 digits (i.e. up to 1 nanosecond resolution),
>  are optional. The "Z" suffix indicates the timezone ("UTC"); the timezone
>  is required. A proto3 JSON serializer should always use UTC (as indicated by
>  "Z") when printing the Timestamp type and a proto3 JSON parser should be
>  able to accept both UTC and other timezones (as indicated by an offset).
> 
>  For example, "2017-01-15T01:30:15.01Z" encodes 15.01 seconds past
>  01:30 UTC on January 15, 2017.
> 
>  In JavaScript, one can convert a Date object to this format using the
>  standard
>  [toISOString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString)
>  method. In Python, a standard `datetime.datetime` object can be converted
>  to this format using
>  [`strftime`](https://docs.python.org/2/library/time.html#time.strftime) with
>  the time format spec '%Y-%m-%dT%H:%M:%S.%fZ'. Likewise, in Java, one can use
>  the Joda Time's [`ISODateTimeFormat.dateTime()`](
>  http://www.joda.org/joda-time/apidocs/org/joda/time/format/ISODateTimeFormat.html#dateTime%2D%2D
>  ) to obtain a formatter capable of generating timestamps in this format.

* Fields

|Field|proto type|JSON type|Comment|Default|Required|
|---|---|---|---|---|---|
|seconds|int64|string| Represents seconds of UTC time since Unix epoch<br> 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to<br> 9999-12-31T23:59:59Z inclusive.|-|false|
|nanos|int|number/string| Non-negative fractions of a second at nanosecond resolution. Negative<br> second values with fractions must still have non-negative nanos values<br> that count forward in time. Must be from 0 to 999,999,999<br> inclusive.|-|false|





